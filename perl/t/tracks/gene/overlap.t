use 5.10.0;
use strict;
use warnings;

package MockBuilder;

use Mouse;
extends 'Seq::Base';

1;

use Test::More;
use lib 't/lib';
use TestUtils qw/ PrepareConfigWithTempdirs /;

use Path::Tiny   qw/path/;
use Scalar::Util qw/looks_like_number/;
use YAML::XS     qw/DumpFile/;

use Seq::Tracks::Gene::Site::SiteTypeMap;
use Seq::Tracks::Reference::MapBases;
use Seq::DBManager;

# create temp directories
my $dir = Path::Tiny->tempdir();

# prepare temp directory and make test config file
my $config_file =
  PrepareConfigWithTempdirs( 't/tracks/gene/overlap.yml',
  't/tracks/gene/db/raw', [ 'database_dir', 'files_dir', 'temp_dir' ],
  'files_dir',            $dir->stringify );

my $baseMapper  = Seq::Tracks::Reference::MapBases->new();
my $siteTypeMap = Seq::Tracks::Gene::Site::SiteTypeMap->new();

# Defines three tracks, a nearest gene , a nearest tss, and a region track
# The region track is simply a nearest track for which we storeOverlap and do not storeNearest
# To show what happens when multiple transcripts (as in NR_FAKE3, NR_FAKE3B, NR_FAKE3C)
# all share 100% of their data, except have different txEnd's, which could reveal issues with our uniqueness algorithm
# such as calculating the maximum range of the overlap: in previous code iterations
# we removed the non-unique overlapping data, without first looking at the txEnd
# and therefore had a smaller-than-expected maximum range
my $seq = MockBuilder->new_with_config( { config => $config_file } );

my $tracks = $seq->tracksObj;

###### First make fake reference track, using the column of sequence data #####

my $refBuilder = $tracks->getRefTrackBuilder();
my $refIdx     = $refBuilder->dbName;

$refBuilder->buildTrack();

my $db = Seq::DBManager->new();

my $geneBuilder = $tracks->getTrackBuilderByName('refSeq');

my $refGetter  = $tracks->getRefTrackGetter();
my $geneGetter = $tracks->getTrackGetterByName('refSeq');

my $siteTypeDbName = $geneGetter->getFieldDbName('siteType');
my $funcDbName     = $geneGetter->getFieldDbName('exonicAlleleFunction');

$geneBuilder->buildTrack();

### We have:

my $regionDataAref = $db->dbReadAll('refSeq/chr10');

my $geneIdx = $geneBuilder->dbName;
my $header  = Seq::Headers->new();

my $features = $header->getParentFeatures('refSeq');

my (
  $siteTypeIdx, $funcIdx, $nameIdx, $name2Idx, $spDispIdx,
  $mrnaIdx,     $spIdx,   $descIdx, $txNumberIdx
);

my $dbLen = $db->dbGetNumberOfEntries('chr10');

for ( my $i = 0; $i < @$features; $i++ ) {
  my $feat = $features->[$i];

  if ( $feat eq 'siteType' ) {
    $siteTypeIdx = $i;
    next;
  }

  if ( $feat eq 'exonicAlleleFunction' ) {
    $funcIdx = $i;
    next;
  }

  if ( $feat eq 'name' ) {
    $nameIdx = $i;
    next;
  }

  if ( $feat eq 'name2' ) {
    $name2Idx = $i;
    next;
  }

  if ( $feat eq 'mRNA' ) {
    $mrnaIdx = $i;
    next;
  }

  if ( $feat eq 'spID' ) {
    $spIdx = $i;
    next;
  }

  if ( $feat eq 'spDisplayID' ) {
    $spDispIdx = $i;
    next;
  }

  if ( $feat eq 'description' ) {
    $descIdx = $i;
    next;
  }

  if ( $feat eq 'txNumber' ) {
    $txNumberIdx = $i;
    next;
  }
}

# Safe for use when instantiated to static variable; no set - able properties
my $coding         = $siteTypeMap->codingSiteType;
my $utr5           = $siteTypeMap->fivePrimeSiteType;
my $utr3           = $siteTypeMap->threePrimeSiteType;
my $spliceAcceptor = $siteTypeMap->spliceAcSiteType;
my $spliceDonor    = $siteTypeMap->spliceDonSiteType;
my $ncRNA          = $siteTypeMap->ncRNAsiteType;
my $intronic       = $siteTypeMap->intronicSiteType;

#                   txStart  txEnd   cdsStart   cdsEnd    exonStarts          exonEnds
# NR_033266 chr19 - 60950    70966   70966      70966  3  60950,66345,70927,  61894,66499,70966,

# NM_001009943 index; has some overlapping values in mRNA, rfamAcc, description
my $targetIdx;
# NM_001009941
my $target2Idx;
my $expSpIds = join( "\t", sort { $a cmp $b } ( 'F8WEI4', 'Q6P6B7' ) );

my $expDesc = join(
  "\t",
  sort { $a cmp $b } (
    'Homo sapiens ankyrin repeat domain 16 (ANKRD16), transcript variant 4, mRNA.',
    'Homo sapiens ankyrin repeat domain 16 (ANKRD16), transcript variant 1, mRNA.'
  )
);

my $exp2SpIds = 'Q6P6B7';

my $exp2Desc =
  'Homo sapiens ankyrin repeat domain 16 (ANKRD16), transcript variant 2, mRNA.';

# We're always only getting a "snp", so posIdx is 0 for the allele
my $posIdx = 0;
for my $pos ( 0 .. $dbLen - 1 ) {
  my $mainDbAref = $db->dbReadOne( 'chr10', $pos );

  my $refBase = $refGetter->get($mainDbAref);
  my $alt     = 'A';

  my $out = [];
  my $refSeqData =
    $geneGetter->get( $mainDbAref, 'chr10', $refBase, $alt, $posIdx, $out );

  my $siteType = $out->[$siteTypeIdx][$posIdx];
  my $names    = $out->[$nameIdx][$posIdx];
  my $symbol   = $out->[$name2Idx][$posIdx];
  my $txNumber = $out->[$txNumberIdx][$posIdx];

  # Tx is NM_019046, none others overlap
  # It is the 3rd tx in the list (NM_001009941 is 1st/idx 0, NM_001009943 is 2nd/idx 1)
  if ( $pos < 16361 ) {
    ok( !ref $siteType );

    ok(
      $txNumber == 2, "The 3rd transcript in the input file is NM_019046,
      and we get the correct txNumber"
    );
    ok( $names eq 'NM_019046' );

    # last exon is utr3; this tx is on negative strand so first exon is really last
    # exonStarts: 0,16371,18572,21280,22243,23997,26121,27315,
    # exonEnds: 966,16562,18651,21442,22352,24040,26342,28172
    # also, 966 is exonEnds, which are open interval, so last base is -1
    if ( $pos <= 966 - 1 ) {
      ok( $siteType eq $utr3 );
      next;
    }

    # closing boundary not needed since > 16361, for clarity only
    # 16371 is exonStarts[1] which is closed interval (so no - 1 to get first base)
    if ( $pos > 966 - 1 && $pos < 16371 ) {
      if ( $pos == 966 || $pos == 967 ) {
        # First 2 bases are really the last; so first 2 should be spliceAcceptor
        # when on negative strand, instead of spliceDonor
        ok( $siteType eq $spliceAcceptor );
        next;
      }

      ok( $siteType eq $intronic );
    }

    next;
  }

  # The merge order may not be completely deterministic
  # However, txNumber is always the order found in the input file
  # and the txNumber will always match the transcript, no matter
  # whether that tx is merged first, second, or third
  ok( $txNumber->[0] == 2 && $txNumber->[1] == 0 && $txNumber->[2] == 1,
    "Can output txNumbers" );
  ok( $names->[0] eq 'NM_019046',    "Can get the correct tx name for 1st merged" );
  ok( $names->[1] eq 'NM_001009941', "Can get the correct tx name for 2nd merged" );
  ok( $names->[2] eq 'NM_001009943', "Can get the correct tx name for 3rd merged" );

  # first condition not needed, simply for consistency
  # 1652 is the first exonEnds for NM_001009943 and NM_001009941, and the 2nd for NM_019046
  if ( $pos >= 16361 && $pos <= 16562 - 1 ) {
    if ( !$targetIdx ) {
      my $idx = 0;

      for my $name (@$names) {
        if ( $name eq 'NM_001009943' ) {
          $targetIdx = $idx;
        }
        elsif ( $name eq 'NM_001009941' ) {
          $target2Idx = $idx;
        }

        $idx++;
      }
    }

    my $spIds = $out->[$spIdx][$posIdx][$targetIdx];
    my $descs = $out->[$descIdx][$posIdx][$targetIdx];
    ok( join( "\t", sort { $a cmp $b } @$spIds ) eq $expSpIds );
    ok( join( "\t", sort { $a cmp $b } @$descs ) eq $expDesc );

    my $spIds2 = $out->[$spIdx][$posIdx][$target2Idx];
    my $descs2 = $out->[$descIdx][$posIdx][$target2Idx];

    ok( $spIds2 eq $exp2SpIds );
    ok( $descs2 eq $exp2Desc );
  }
  #   ok($out->[$siteTypeIdx][0] eq $intronic);
}

# ok($inGeneCount == $hasGeneCount, "We have a refSeq record for every position from txStart to txEnd");

$db->cleanUp();

done_testing();
